# 3장. 패러다임 개요

<br>

## 구조적 프로그래밍
- 최초로 적용된 패러다임
- 무분별한 점프(`goto`)는 해롭다는 사실에서 출발
  - 코드의 가독성을 망쳐 코드의 흐름을 어지럽게 하기 떄문이 아닐까?
- `if`, `then`, `else`, `do`, `while`, `until`과 같은 구조로 대체
- 제어흐름의 직접적인 전화에 대해 규칙 부과

<br>

## 객체 지향 프로그래밍
- 함수 호출이 반환된 후에도 함수 내의 지역 변수가 유지될 수 있다는 개념에서 출발
- 제어흐름의 간접적인 전화에 대해 규칙 부과

<br>

## 함수형 프로그래밍
- 람다 계산법에서 출발
  - 불변성, 심볼의 값이 변경되지 않음
- 함수형 언어에는 할당문이 없음
- 할당문에 대해 규칙을 부과

---

<br>

# 4장. 구조적 프로그래밍
`if`, `then`, `else`, `do`, `while`, `until`과 같은 분기와 반복을 사용해 모듈을 작은 단위로 쪼개고 분할 정복을 사용한다.

즉, 구조적 프로그래밍을 통해 모듈을 증명 가능한 작은 단위로 재귀적으로 분해할 수 있다.

기능적으로 분해된 모듈은 제어 구조를 이용해 코드로 표현가능하다.

#### 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 분해하고 테스트를 통해 세부 기능들이 거짓인지를 증명하려 시도한다.

거짓임을 증명하는 테스트가 실패한다면, 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

<br>

---

<br>

# 5장. 객체 지향 프로그래밍
좋은 아키텍처는 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

## 캡슐화
데이터와 함수가 응집력 있게 구성된 집단(클래스)를 서로 구분 짓고 구분선 밖으로 데이터는 은닉되고 일부 함수만이 외부에 노출된다. -> `private`, `public`

개발자는 올바르게 행동해 캡슐화를 지키려 노력해야한다.

## 상속
객체 지향 언어는 상속을 편리하게 제공한다.

상속의 치명적인 단점도 고려하자.

## 다형성
객체 지향 언어가 가진 가장 뛰어난 장점인 다형성을 활용하면 시스템을 매우 유연하고 유지보수가 쉬운 시스템으로 만들 수 있다.(플러그인 아키텍처)

## 의존성 역전
다형성을 활용하면 의존성 역전이 일어난다.

`SOLID`에서 설명하는 의존성 역전 원칙을 다음과 같이 설명한다.

**객체는 저수준의 모듈보다 고수준의 모듈에 의존해야한다.**

객체 지향 언어가 다형성을 편리하고 안전하게 제공한다는 사실은 소스 코드의 의존성을 어디서든 역전시킬 수 있다는 의미이다.

```java
public class Car {
    private ForwardEngine forwardEngine;

    public Car(ForwardEngine forwardEngine) {
        return this.forwardEngine = forwardEngine;
    }

    public void move() {
        forwardEngine.start();
    }
}

public class ForwardEngine {
    public void start() {
        System.out.println("앞으로 전진합니다.");
    }
}
```

위 코드를 살펴보자.

`Car`클래스는 `ForwardEngine`에 의존하고 있고, 제어의 흐름 또한 같다.

만약 뒤로만 가야하는 차를 만들어야한다면 `BackwardEngine`이라는 클래스를 만들어야하고, `Car` 클래스의 코드도 수정해줘야한다.(OCP 위반)

움직이게 만든다는 엔진의 공통 사항을 추상화하여 인터페이스로 만들어보자.

```java
public class Car {
    private Engine engine;

    public Car(Engine engine) {
        return this.engine = engine;
    }

    public void move() {
        engine.start();
    }
}

public interface Engine {
    void start();
}

public class ForwardEngine implements Engine {
    public void start() {
        System.out.println("앞으로 전진합니다.");
    }
}
```

이제 `Car`는 `Engine` 클래스에 의존한다. 그렇다면 제어의 흐름또한 같은가?

그렇지 않다. 제어의 흐름은 `Engine` 클래스를 구현한 저수준의 모듈로 흐른다.

추후에 변경이 생기더라도 `Car` 클래스는 수정하지 않아도된다.

훨씬 더 유연해지고 변경에 대응하기 쉬워졌다.

더 나아가 각 컴포넌트들은 개별적이고 독립적이게 된다.

서로의 수정이 전혀 영향을 미치지 않게 된다는 뜻이다. -> **개발 독립성, 배포 독립성**

#### 객체 지향이란 다형성을 이용해 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

<br>

---

<br>

# 6장. 함수형 프로그래밍
경쟁 조건, 교착 상태, 동시성 문제는 모두 가변 변수로 인해 발생한다.

내부 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리해 불변 컴포넌트에서는 함수형 방식으로만 작업을 처리한다.(가변 변수 x)

이 불변 컴포넌트는 변수의 상태를 변경할 수 있는 다른 컴포넌트와 통신한다.

가능한 많은 처리를 불변 컴포넌트로 옮기고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야한다.

저장 공간과 처리 능력이 충분하면 완전한 불변성을 만들 수 있다.

