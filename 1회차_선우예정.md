# 3. 패러다임 개요
---------------------------------------
## 구조적 프로그래밍 (Structured Programming)
- 최초로 적용된 패러다임
- 제어흐름의 **직접적인 전환**에 대해 규칙을 부과

## 객체지향 프로그래밍 (Object-oriented Programming)
- 함수 호출 스택 프레임(stack frame)을 힙(heap)으로 옮기면 함수 호출이 반환된 이후에도 선언된 지역변수가 오랫동안 유지될 수 있음을 발견
    - 함수 → 클래스의 생성자
    - 지역 변수 → 인스턴스 변수
    - 중첩 함수 → 메서드
    - 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 다형성 등장
- 제어흐름의 **간접적인 전환**에 대해 규칙을 부과

## 함수형 프로그래밍 (Functional Programming)
- 세 패러다임 중 가장 먼저 만들어진 패러다임으로 컴퓨터 프로그래밍보다 먼저 등장
- 람다 계산법의 영향으로 만들어진 패러다임
    - 람다 계산법의 기초 - 불변성 : 심볼값이 변경되지 않는다는 개념
- 할당문에 대해 규칙을 부과

## 생각할 거리
각 패러다임은 프로그래머에게서 권한을 박탈하며 새로운 권한을 부여하지 않는다.
각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다.
(즉, 패러다임은 무엇을 해야할지를 말하기보다 무엇을 해서는 안되는지를 말해준다.)
⇒ 박탈할 권한이 남아있지 않으므로 새로운 패러다임이 등장할 수 없다.

## 결론
아키텍처의 경계를 넘나들기 위한 매커니즘으로 다형성을 이용한다.
함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.
모듈의 기반 알고리즘으로 구조적 프로그래밍을 이용한다.

**세 가지 패러다임 - 아키텍처의 세 가지 큰 관심사 (함수 / 컴포넌트 분리 / 데이터 관리)**



# 4. 구조적 프로그래밍
---------------------------------------
## 증명
### 문제점
- 프로그래밍은 어렵고 프로그래머는 프로그래밍을 잘하지 못한다.
- 아주 작은 세부 사항이라도 간과하면 프로그램이 동작하는 것처럼 보여도 결국에는 예상 외의 방식으로 실패한다.

### 해결방법
‘증명(proof)’이라는 수학적 원리를 적용하여 문제를 해결
공리, 정리, 따름정리, 보조정리로 구성되는 **유클리드 계층 구조**를 만드는 것
⇒ 프로그래머는 입증된 구조를 이용하고 구조를 코드와 결합시키며 코드가 올바르다는 사실을 스스로 증명하게 되는 방식

### 연구내용
- goto 문장이 재귀적으로 모듈을 더 작은 단위로 분해하는 과정에서 문제 발생
- 분기와 반복이라는 단순한 제어 구조에서는 goto 문장을 사용하더라도 모듈을 분해 가능
- 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로 모듈을 재귀적으로 세분화 가능
- 제어구조는 순차 실행과 결합했을 때 특별
- 모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 세 가지 구조로 표현 가능

### 순차(sequence)
- 단순한 열거법을 이용해 순차 구분이 올바른 것을 입증
- 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적

### 분기(selection)
- 열거법을 재적용하는 방식으로 처리
- 분기를 통한 경로를 열거하였고 두 경로가 수학적으로 적절한 결과를 만들어 낸다면 증명 성립

### 반복(iteration)
- 귀납법(induction)을 사용
- 열거법에 따라 1의 경우가 올바름을 증명했고 N의 경우가 올바르다고 가정할 때 N+1의 경우도 올바른 것을 증명
- 반복의 시작 조건과 종료 조건도 열거법을 통해 증명

⇒ 프로그램에서도 정리에 대한 유클리드 계층구조를 만들 수 있을 거 같았으나 실패


## 테스트
### 과학적 방법
반증은 가능하지만 증명은 불가능
서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작
‘테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다.’ = 프로그램이 잘못되었음을 증명할 수는 있지만 프로그램이 맞다고 증명할 수는 없다.


## 결론
### 구조적 프로그래밍이 오늘날까지 가치 있는 이유
- 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력
- 현대적 언어가 아무런 제약 없는 goto문장은 지원하지 않는 이유
- 아케텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 노력해야 하며 이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.



# 5. 객체지향 프로그래밍
---------------------------------------
## 캡슐화 (encapsulation)
- 객체 지향 언어는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법 제공
- 캡슐화를 통해 데이터와 함수가 구성된 집단을 구분짓는 선을 생성
    - 구분선 바깥에서 데이터는 은닉되고 일부함수만 노출
    - private 멤버 데이터 / public 멤버 함수
- pulbic, private, protected 키워드를 도입하여 불완전한 캡슐화를 보완하였으나 임시방편

⇒ 객체 지향 프로그래밍은 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을 것이라는 믿음을 기반으로 하지만 객체 지향 언어들은 C언어에서 누렸던 완벽한 캡슐화 약화


## 상속 (inheritance)
- 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일
- 객체 지향 언어가 고안되기 이전에도 상속과 비슷한 기법이 사용되었지만 객체 지향 언어에서는 업캐스팅(upcasting)이 암묵적으로 수행

⇒ 객체 지향 언어가 완전히 새로운 개념을 만들지는 못했지만 데이터 구조에 가면을 씌우는 일을 편리한 방식으로 제공


## 다형성 (polymorphism)
- 유닉스 운영체제는 모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구
    - 열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)
- FILE 데이터 구조는 위의 다섯 함수를 가리키는 포인터들을 포함
- 함수를 가리키는 포인터를 응용한 것이 다형성

⇒ 객체 지향 언어는 다형성을 제공하지는 못했지만 좀 더 안전하고 더욱 편리하게 사용 가능

### 다형성이 가진 힘
새로운 장치에서 복사프로그램을 동작하게 만드려면 어떻게 수정해야 할까?
→ 아무런 변경도 필요하지 않으며 다시 컴파일할 필요도 없다. (복사 프로그램의 소스코드는 입출력 드라이버의 소스코드에 의존하지 않기 때문)

즉, 입출력 드라이버가 복사 프로그램의 플러그인(plugin)이 된 것이다.

### 플러그인 아키텍처
- 입출력 장치 독립성을 지원하기 위해 만들어졌고 거의 모든 운영체제에서 구현
- 객체 지향 언어의 등장으로 언제 어디서든 플러그인 아키텍처 적용 가능


## 의존성 역전
### 다형성을 적용하기 전의 소프트웨어
- 전형적인 호출 트리
    - main → 고수준 함수 → 중간 수준 함수 → 저수준 함수
    - 의존성의 방향은 반드시 제어흐름을 따르는 상황
### 다형성을 적용하였을 경우
- 소스 코드 의존성(상속 관계)이 제어흐름과는 반대

⇒ 객체지향 언어가 다형성을 안전하고 편리하게 제공 = 소스 코드 의존성을 어디에서든 역전 가능


## 결론

**소프트웨어 아키텍처 관점**에서 **객체 지향**이란 **다형성**을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 **절대적인 제어 권한을 획득**할 수 있는 능력이다.

- OO를 사용하면 아키텍트는 **플러그인 아키텍처를 구성**할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 **독립성을 보장**할 수 있다.
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고 고수준의 정책을 포함하는 모듈과는 **독립적으로 개발하고 배포**할 수 있다.



# 6. 함수형 프로그래밍
---------------------------------------
## 불변성과 아키텍처
### 아키텍트는 왜 변수의 가변성을 고려할까?
경합(race) 조건, 교착상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문이다.
어떠한 변수도 갱신되지 않는다면 문제가 발생하지 않는다.

### 불변성이 실현 가능한 문제일까?
실현 가능하다. 단, **저장공간의 무한**하고 **프로세서의 속도가 무한히 빠르다**는 전제가 필요하다.
