## **9장 LSP: 리스코프 치환 원칙**

### **하위 타입이란**

치환의 개념을 인지하고 생각하고 아래 경우를 살펴보자.

S 타입의 객체 Olive에 대응하는 T타입 객체 Material이 있고, T타입을 이용해 정의한 모든 프로그램에서 Material 자리에 Olive를 치환하더라도 프로그램의 행위가 변하지 않는다면, Olive는 Material의 하위 타입이다.

즉, 프로그램의 소스코드 변경없이 타입 Material을 Olive로 치환(교체)해도, 프로그램이 정상 동작할 수 있어야 한다는 원칙이다

### 타입에 의존하지 않는 구조

LSP를 준수하는 설계는 애플리케이션의 행위가 타입에 강하게 의존하지 않는다.

### LSP의 연혁

객체 지향 초창기에는 LSP는 상속을 사용하도록 가이드했지만, 시간이 지나면서 인터페이스와 구현체에도 적용되는 더 광범위한 설계 원칙으로 변모했다.

### 결론

LSP는 컴포넌트부터 아키텍처 수준까지 확장이 가능하고, 확장해야만 한다. 

치환 가능성을 고려하지 않으면 시스템이 오염될 확률이 아주 높아진다.

## 10장 ISP: 인터페이스 분리 원칙
![ISP](../3회차/images/ISP.png)

위 관계에서 세 명의 사용자가 OPS 클래스를 사용하고 있다. User1은 op1, User2는 op2, User3은 op3만을 사용한다.

User1은 op 2,3를 사용하지 않음에도 두 메서드에 의존하게 된다. 따라서 이러한 의존성으로 인해 op2의 소스 코드가 변경되면 User1도 재컴파일 후 배포를 해야한다.

하지만 유저 사이에 인터페이스를 서로 의존하게끔 하면, 의존성이 인터페이스를 바라보아 분리시킬 수 있고, 결과적으로 아까와 같은 행위를 하지 않아도 된다.

필요 이상으로 많은 걸 포함하는 모듈에 의존한다면 불필요한 재컴파일과 재배포를 강제한다.

## 11장 DIP: 의존성 역전 원칙
![DIP](../3회차/images/DIP.png)

DIP에서 말하는 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

하지만 소프트웨어 시스템은 구체적인 많은 장치에 의존하기 때문에 비현실적인 말로 다가온다.

다만, 여기서부터는 이제 변경될 일이 거의 없고, 있더라도 엄격하게 통제되는 클래스와 개발 중과 같은 변동성이 큰 구체 클래스로 구분을 짓는다.

DIP를 논할 때는 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 용남하는 편이다. 다시 말해, 변경되지 않는다면 구체에 의존할 수 있다.

다만, 이제 우리가 의존하지 않으려고 하는 것은 변동성이 큰 구체 클래스이다.

### 안정화된 추상화

- 인터페이스가 변경되면 이를 구현한 구체 클래스들도 수정되어야 하고, 반대로 구현체에 변경이 생긴다면 인터페이스는 대부분 변경될 필요가 없다.
    - 즉, 인터페이스가 구현체보다 변동성이 낮다.
- 안정된 소프트웨어 아키텍처는 변동성이 큰 구현체에 의존하는 일을 지양하고, 안정된 인터페이스를 선호한다.

### 팩토리



- 여기서 곡선은 아키텍처의 경계를 의미한다.
- 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다.
- 곡선을 경계로 두 가지 컴포넌트로 분리한다.
    - 추상 컴포넌트: 애플리케이션의 모든 고수준 업무 규칙을 포함
    - 구체 컴포넌트: 업무 규칙을 다루기 위해 필요한 모든 세부사항
- 해당 곡선과 교차되는 부분에서는 의존성이 모두 추상을 향하는 것을 볼 수 있다.
    - 다시 말해, 소스 코드 의존성이 제어흐름과 반대로 역전되는 모습인데, 이를 의존성 역전이라고 부른다.

### 구체 컴포넌트

- 구체 컴포넌트에는 구체적인 의존성이 있어 DIP에 위배되지만, 이는 일반적인 모습이다.
- DIP 위배를 모두 없앨 수는 없지만, DIP를 위배하는 클래스들을 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 격리할 수 있다.